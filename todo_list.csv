Problems,Difficulty,Solved,Notes (In Japanese)
"Array, Math, String",,,
Fizz Buzz,Easy,○,有名な問題
"Pow(x, n)",Medium,○,繰り返し二乗法を用いてO(logN)に落とす
Rotate Array,Easy,○,２つの部分列をそれぞれ反転させた後、全体の列を反転させる。
Non-decreasing Array,Easy,○,貪欲法っぽい感じでO(N)で解く。
Remove Duplicates from Sorted Array,Easy,○,Two Pointersを使うとO(N)でIn-Placeで解ける。
Sort Array By Parity,Easy,○,Two Pointersを用いるとIn-PlaceでO(N)で解ける。
Sort Array By Parity II,Easy,○,Two Pointersを用いるとIn-PlaceでO(N)で解ける。偶奇の数は等しいので、片方の走査が終わった場合もう片方も終わっている。
String Compression,Easy,○,Two Pointersを使って空間計算量O(1)で解く。
Implement strStr(),Easy,○,ブルートフォースで解くのが一番速い。BM法やKMP法は特殊なケースに効きそう。
Factorial Trailing Zeroes,Easy,○,素因数に関しては5に関してのみ調べれば良く、2について調べる必要はないことに注意。
Excel Sheet Column Number,Easy,○,26進数の問題となることに注意。
Move Zeroes,Easy,○,走査用ポインタに加えて、0と交換する為のポインタを作って利用する。
Flipping an Image,Easy,○,問題文に従ってそのまま解く。
Count Primes,Easy,○,エラトステネスの篩で素数リストを作って、その長さを返す。
Shortest Unsorted Continuous Subarray,Easy,○,Two Pointersの前順/逆順操作でO(N)で解ける。境界条件に気を付ける。
Robot Return to Origin,Easy,○,countメソッドを使っても良い。
Palindrome Number,Easy,○,基本的な算術演算を用いて、再帰的に整数を反転させる。
Find All Numbers Disappeared in an Array,Easy,○,バケツソートorハッシュテーブルを用いた方法はO(N)だが、余分なメモリを使うのでダメ。
Add Strings,Easy,○,文字列として処理しないと、多倍長整数を扱うPythonやJavaのBigInteger以外ではオーバーフローしてしまうことに注意。
Plus One,Easy,○,リストの最後尾から繰り上がりを足していき、O(N)で解く。
Count and Say,Easy,○,ヘルパー関数を作ることによって、やや実装が見やすくなる(気がする)。
To Lower Case,Easy,○,ASCIIコード表を利用して変換する。
Detect Capital,Easy,○,ビルトインメソッドを利用する。
Roman to Integer,Easy,○,ハッシュテーブルを作ってやると簡単。
Integer to Roman,Medium,○,ハッシュテーブルを作ってやると簡単。
Merge Sorted Array,Easy,○,nums1とnums2を最後尾から比較しつつ、nums1に逆順で要素を入れていけば良い
Add Binary,Easy,○,再帰で解くと綺麗に書ける。リストのアクセスはO(1)なので計算量はO(N)となる。
Reverse String,Easy,○,reverseメソッドや、リストのスライスの逆順操作を用いても0(1)のin-placeになる。
Reverse Vowels of a String,Easy,○,小文字だけでなく大文字も母音となることに注意。
Reverse Integer,Easy,○,数字の文字列をintでキャストすると接頭の0を消すことができる。また文字列の逆順はスライスで行うのが便利。
Most Common Word,Easy,○,splitメソッドはスペースが複数個でも、自動的にスペースなしの単語リストに分割してくれる。
Multiply Strings,Medium,,
Super Ugly Number,Medium,,
Minimum Time Difference,Medium,○,時間を分に直してソートした後、前順に比較していく。最小時間+1440分を追加するとコードが簡単になる。また、バケツソートを用いるとO(N)にもできる。
Find All Duplicates in an Array,Medium,,
Longest Common Prefix,Easy,○,zip関数をアスタリスク付きで上手く使う。
Flip Game,Easy,○,題意に従ってそのまま解く。
Flip Game II,Medium,,
Game of Life,Medium,○,状態遷移のパターンごとに0-1以外の値を代入し、上手くIn-Placeで解く。
Set Matrix Zeroes,Medium,○,一番上の行と列を0埋めのためのメモとして保存しておく。空間計算量だけではなく時間計算量にも注意。
Next Permutation,Medium,○,最悪計算量はO(N)、償却計算量はO(1)となる
Summary Ranges,Medium,○,ヘルパー関数を用意すると実装が簡単になる。最後の文字はループから外して別に処理するのがポイント。
Product of Array Except Self,Medium,○,前順走査と逆順走査のTwo PassでO(N)で解く。
Maximum Average Subarray I,Easy,○,Sliding Windowで解く。ブルートフォースだとO(NK)になってしまう。
Maximum Average Subarray II,Hard,,
Rotate Image,Medium,○,zip関数を使うと簡単。返却値(リストの中身)がタプルとなることに注意。
Spiral Matrix,Medium,○,テンプレなので解き方を覚える。len([])は通るが、len([][0])はアクセスエラーになることに注意。
Spiral Matrix II,Medium,○,上とほぼ同じ問題。テンプレなので解き方を覚える。
Largest Number,Medium,○,Python3ではcmpパラメータは廃止されたので、代わりにkeyパラメータにcmp_to_keyでラップした比較関数を渡す。
ZigZag Conversion,Medium,○,シンプルにそのまま走査する。
String to Integer (atoi),Medium,○,問題の様々な条件を確認することが求められる、コーディング面接的な問題。
Fraction to Recurring Decimal,Medium,○,割り算の流れをそのまま素直に実装する。
Encode and Decode Strings,Medium,,
Reverse Words in a String,Medium,○,ビルトインメソッドを使うと一瞬でできる。真面目に解く場合はTwo Pointersを用いる。
Insert Delete GetRandom O(1),Medium,○,挿入した値の位置をメモするための辞書を作っておく。
Insert Delete GetRandom O(1) - Duplicates allowed,Hard,,
Reorder Log Files,Easy,○,Pythonのビルトインのソートは安定ソートとなることを利用すると楽に書ける。
Simplify Path,Medium,○,splitメソッドを使うとかなり簡単に書ける
Find Duplicate File in System,Medium,○,ハッシュテーブルを作って解く。
Remove Sub-Folders from the Filesystem,Medium,○,ソートした後、前のフォルダのPath＋スラッシュと一致したらスルーする。スラッシュを追加しないとうまく機能しないことに注意。
Longest Absolute File Path,Medium,○,タブや改行はPythonだと一文字で取り出せることに注意。コーナーケースが多い。
Text Justification,Hard,○,貪欲に空欄を追加していく。文字が一列に一つだけの場合に注意。
Shuffle an Array,Medium,,
Beautiful Array,Medium,,
K-th Symbol in Grammar,Medium,○,N=2やN=３の時を参考に、N=1かつK==1のベースケースに収束するように再帰を上手く書く。
Wiggle Sort,Medium,○,条件を満たさない箇所を貪欲にスワップしていく事で、自然に題意を満たす列となる。
Wiggle Sort II,Medium,,
Missing Ranges,Medium,,
Increasing Triplet Subsequence,Medium,,
Find the Celebrity,Medium,,
Longest Substring with At Least K Repeating Characters,Medium,,
Insert Interval,Hard,,
Longest Consecutive Sequence,Hard,○,ハッシュマップを使ってO(N)で解く。バケツソートでもO(N)で解ける。
First Missing Positive,Hard,○,配列内に存在する数には負の符号をつけていき、O(N)/O(1)で処理する。
Shortest Palindrome,Hard,,
Valid Number,Hard,○,コーディング面接のような問題。様々な条件をしっかり議論する。
Consecutive Numbers Sum,Hard,,
Read N Characters Given Read4,Easy,,
Read N Characters Given Read4 II - Call multiple times,Hard,,
,,,
Trie,,,
Implement Trie (Prefix Tree),Medium,○,トライノードを格納する辞書を用いてトライ木を実装する。パトリシア木/LOUDS/ダブル配列などの実装もある。
Add and Search Word - Data Structure Design,Medium,○,PrefixSearchを行う必要がないため、リストを持つ辞書を作って解く。
Implement Magic Dictionary,Medium,,
Map Sum Pairs,Medium,,
Replace Words,Medium,,
Maximum XOR of Two Numbers in an Array,Medium,,
Top K Frequent Words,Medium,○,比較演算用のクラスを作って問題を解く。heapqのpopは最小値から出てくることに注意。
Word Search,Medium,○,バックトラック法で解く。
Word Search II,Hard,,
Word Squares,Hard,,
Palindrome Pairs,Hard,○,各文字列を逆順にした辞書を用意して、O(NK**2)で解く。(Nは文字列の数、Kは文字列の長さ)
Design Search Autocomplete System,Hard,,
,,,
LinkedList,,,
Reverse Linked List,Easy,○,繰り返しと再帰の2ver.で解く (どちらも時間計算量はO(N))
Reverse Linked List II,Medium,,
Reverse Nodes in k-Group,Hard,,
Linked List Cycle,Easy,○,ランナーテクニックでフロイドの循環検出法を実装
Linked List Cycle II,Medium,○,実装は簡単。Noneの比較は==ではなくisで行う。
Add Two Numbers,Medium,○,ミュータブル/イミュータブル/参照の代入について理解する
Add Two Numbers II,Medium,○,スタックを用いて、各連結リストの中身を変更せずに解く。複数変数への同時代入は各式が左から順番に処理されていくことに注意。
Remove Linked List Elements,Easy,○,ダミーノードを作り、前順に走査していく。
Delete Node in a Linked List,Easy,○,削除したいノードに直接アクセスできるのでO(1)で処理できる。
Remove Duplicates from Sorted List,Easy,○,ポインタを付け替えるだけ
Remove Duplicates from Sorted List II,Medium,○,ダミーノードを作って上手く処理する
Remove Nth Node From End of List,Medium,○,参照の代入に気を付ける。n+aのfast/slowランナーを利用。
Copy List with Random Pointer,Medium,○,辞書を使って連結リストを処理
Palindrome Linked List,Easy,○,列の中間のノードを見つけて、その前後どちらかの列を逆順にして片方の列と比較していく。
Intersection of Two Linked Lists,Easy,○,それぞれ終端まで走査していき、列の長さを記録した後、それを用いて交差点を検出。
Odd Even Linked List,Medium,,
Reorder List,Medium,○,中央値発見/逆順並び替え/交互にマージの総合問題
Sort List,Medium,,
Swap Nodes in Pairs,Medium,○,一時変数を用いてノードを入れ替えていく。
Merge Two Sorted Lists,Easy,○,None or TrueはTrueになることに注意する
Merge k Sorted Lists,Hard,○,優先度付きキューを使う総合問題
Design Linked List,Easy,,
Flatten Binary Tree to Linked List,Medium,,
Convert Binary Search Tree to Sorted Doubly Linked List,Medium,,
LRU Cache,Medium,○,双方向連結リスト＋辞書を使う総合問題
LFU Cache,Hard,,
,,,
Stack,,,
Valid Parentheses,Easy,○,辞書を使って解く(括弧の向きが逆になることに注意)
Min Stack,Easy,○,最小値保存用のスタックを別に作成する
Max Stack,Easy,○,最大値保存用のスタックを別に作成する。popMaxと空間計算量がO(N)になるため、この操作が頻繁に行われる際には別のアプローチを使う。
Decode String,Medium,○,繰り返し回数保存用のスタックを別に作成する
Reverse Substrings Between Each Pair of Parentheses,Medium,○,上記とほぼ同様の問題。
Daily Temperature,Medium,○,スタックを用いてforwardのループで上手く処理する
Flatten Nested List Iterator,Medium,○,pop()をO(1)で用いるために、最初にリストを逆順にする
Evaluate Reverse Polish Notation,Medium,,
Asteroid Collision,Medium,,
Trapping Rain Water,Hard,,
Trapping Rain Water II,Hard,,
Largest Rectangle in Histogram,Hard,,
Odd Even Jump,Hard,,
Basic Calculator,Hard,,
Basic Calculator II,Medium,,
Basic Calculator III,Hard,,
,,,
Queue,,,
Moving Average from Data Stream,Easy,○,Stream処理系タスクは基本的にキューを使う感じになる印象。
Kill Process,Medium,,
Task Scheduler,Medium,○,キューを使ってO(NlogN)で解く方法と、O(N)で貪欲的に求める方法がある。
Design Circular Queue,Medium,,
Design Circular Deque,Medium,,
Design Snake Game,Medium,,
,,,
"Heap, PriorityQueue",,,
Kth Largest Element in a Stream,Easy,○,長さがKのヒープを用いて処理する。
K Closest Points to Origin,Medium,○,ヒープを使うと計算量をO(NlogN)からO(K+(N-K)logK)に落とせる。クイックセレクトの利用もあり。
Kth Largest Element in an Array,Medium,○,ヒープを使うと計算量をO(NlogN)からO(K+(N-K)logK)に落とせる。クイックセレクトの利用もあり。
Top K Frequent Elements,Medium,○,ヒープを使うと計算量がO(NlogN)となる。ハッシュマップ&バケツソートでO(N)にも出来る。
Find K Pairs with Smallest Sums,Medium,○,コーナーケースが多いので気をつける。ヒープを使うと計算量をO(NMlogNM)からO(KlogK)に落とせる。
Find Median from Data Stream,Hard,○,mixheapとmaxheapを用いて、addはO(logN)、findはO(1)で解く。
,,,
"HashMap, HashTable",,,
Jewels and Stones,Easy,○,ハッシュテーブルを使って普通に解く。
Subdomain Visit Count,Easy,○,ドメイン毎のハッシュテーブルを作って値を管理する。
Happy Number,Easy,○,ハッピー列が最終的に循環列になるという性質を利用する。
Two Sum,Easy,○,ハッシュテーブルを用いてO(N)で処理。_ in dictはvalueではなくkeyを見つける事に注意。
Two Sum II - Input array is sorted,Easy,○,Two Sumと同じくハッシュマップでO(N)で解けるが、ソートされてるのでTwo PointersでもO(N)で解ける。
Two Sum III - Data structure design,Easy,○,解き方はTwo Sumと同じ。addとfindの計算量のトレードオフを考慮する。(DBの利用用途としてaddは多いがfindは少ないなど)
Find Common Characters,Easy,○,Counterメソッドを使うと簡単に解ける。
Keyboard Row,Easy,○,set型の部分集合判定は不等号でできることを利用する。
Design HashMap,Easy,○,チェイン法を連結リストで実装する。returnとbreakの違いに注意。
Design HashSet,Easy,,
Design A Leaderboard,Medium,○,ハッシュマップを用いるとtop以外O(1)でできる。どの操作の計算量を減らすべきかは場合によりそう。
4Sum,Medium,○,3sumとほぼ同様の解き方でO(N^3)で解く。
4Sum II,Medium,○,ハッシュテーブルを使うとO(N^2)/O(N^2)で解ける。
Group Shifted Strings,Medium,,
Strobogrammatic Number,Easy,○,ストロボグラマティック数のハッシュテーブルを作って解く。
Strobogrammatic Number II,Medium,,
Strobogrammatic Number III,Hard,,
Intersection of Two Arrays,Easy,○,setを用いて処理すると簡単。
Intersection of Two Arrays II,Easy,○,Counterを用いて処理すると簡単。Follow-UpはソートやTwo Pointersを用いて解く。
Shortest Word Distance,Easy,○,ハッシュマップでO(N^2)かOne-PassでO(N)か、どちらで解くべきかはクエリの量で決める。
Shortest Word Distance II,Medium,,
Shortest Word Distance III,Medium,,
H-Index,Medium,,
Valid Anagram,Easy,○,ビルトインメソッドを使うと簡単。
Valid Palindrome,Easy,○,Two PointersでO(N)で解ける。
Valid Palindrome II,Easy,○,Two PointersでO(N)で解ける。
Unique Word Abbreviation,Medium,,
Unique Email Addresses,Easy,○,ビルトインメソッドのsplitとreplaceを使うと簡単。
First Unique Character in a String,Easy,○,ハッシュマップを使ってTwo Passで解く。
Find All Anagrams in a String,Easy,,
Island Perimeter,Easy,○,True or 配列外のアクセスエラーはTrueとなることを利用。アクセスエラーを防ぐために外周を0埋めしても良い。
Contains Duplicate,Easy,○,ハッシュテーブルを用いてそのまま解く。setはO(N)でlenはO(1)となる。
Contains Duplicate II,Easy,○,ハッシュテーブルを用いてO(N)で解く。愚直に解くとO(N^2)となる。
Contains Duplicate III,Medium,,
Palindrome Permutation,Easy,○,ハッシュテーブルを用いてO(N)で解く。メモリを使いたくなければ、ソートを使ってO(NlogN)でも解ける。
Palindrome Permutation II,Medium,,
Group Anagrams,Medium,○,ハッシュテーブルを用いてO(N)で処理。dict.values()はPython3ではイテレータが返ってくることに注意。
Encode and Decode TinyURL,Medium,○,システムデザイン的な問題。base62で6桁だと62^6(約56.8Billion)のUniqueURLをカバーできる。
Subarray Sum Equals K,Medium,○,累積和のハッシュマップを作ってO(N)で解く。Two Sumと似た問題。
Subarray Sums Divisible by K,Medium,,
Binary Tree Vertical Order Traversal,Medium,,
Integer to English Words,Hard,○,再帰で書くと綺麗に書ける。2**32は10**9(Billion)から10**10(Ten Billion)の間であることに注意。
,,,
"Tree, BT, BST",,,
Same Tree,Easy,○,適当な走査法で全探索しつつ２つの木を比較していく。
Symmetric Tree,Easy,○,再帰やBFSで、内側と外側に分けて対称性をチェックしつつ走査する。最初に部分木が分かれるため、離れたノードの対称性もチェックできる。
Merge Two Binary Trees,Easy,○,適当な走査法で全探索しつつ２つの木を足していく。
Subtree of Another Tree,Easy,○,DFSなどで再帰的に探索する。21行目のショートカットを入れると速度が大分速くなるが、ノードの値が全て異なる場合のみで動作する。
Balanced Binary Tree,Easy,,
Invert Binary Tree,Easy,○,適当な走査法で全探索しつつ左右を反転していく。
Range Sum of BST,Easy,○,適当な走査法で枝狩りしつつ全探索していく。
Binary Tree Paths,Easy,○,適当な走査法で探索しつつ、探索中のノードの左右の子がNoneになったら文字列を追加していく。
Diameter of Binary Tree,Easy,,
Minimum Depth of Binary Tree,Easy,○,適当な走査法で木の高さを保存しながら探索しつつ、葉に到達したら終了する。
Maximum Depth of Binary Tree,Easy,○,DFSで簡単に解ける。上記の問題とは微妙に異なる。
Convert BST to Greater Tree,Easy,○,inorderの左右逆Versionで解く。
Convert Sorted Array to Binary Search Tree,Easy,○,再帰で解く。計算量はT(n)=2T(n/2)+O(1)より、マスター定理を用いてO(N)となる。
Convert Sorted List to Binary Search Tree,Medium,,
Closest Binary Search Tree Value,Easy,,
Closest Binary Search Tree Value II,Hard,,
Binary Tree Right Side View,Medium,,
Verify Preorder Serialization of a Binary Tree,Medium,,
Path Sum,Easy,○,適当な走査法で探索済みノードの値の総和を渡しつつ探索。
Path Sum II,Medium,,
Path Sum III,Easy,,
Path Sum IV,Medium,,
Longest Univalue Path,Easy,,
Two Sum IV - Input is a BST,Easy,,
Kth Smallest Element in a BST,Medium,,
Inorder Successor in BST,Medium,,
Binary Search Tree Iterator,Medium,,
Validate Binary Search Tree,Medium,○,DFS/BFSで条件を確認しつつ走査する。最大値/最小値を渡さなくても済む方法もある。
Unique Binary Search Trees,Medium,,
Binary Tree Longest Consecutive Sequence,Medium,,
Binary Tree Longest Consecutive Sequence II,Medium,,
Lowest Common Ancestor of a Binary Search Tree,Easy,○,ルートの値とp/qの値を比較して、左右どちらの部分木に降りるかを毎回決める。
Lowest Common Ancestor of a Binary Tree,Medium,○,Iterativeな場合、親への繋がりを記録する辞書を作って解く。再帰的にも解ける。
Binary Tree Inorder Traversal,Medium,,
Binary Tree Preorder Traversal,Medium,,
Binary Tree Postorder Traversal,Hard,,
Binary Tree Level Order Traversal,Medium,○,Level OrderなのでBFSが自然だが、Levelを渡しながら走査すればDFSでも解ける。
Binary Tree Level Order Traversal II,Easy,,
Binary Tree Zigzag Level Order Traversal,Medium,○,Binary Tree Level Order Traversalとほぼ同じ。作成したリストの奇数番目を最後に反転させる方法でも良い。
Construct Binary Tree from Preorder and Inorder Traversal,Medium,○,Inorder/Postorderの場合と対比させて考えるとわかりやすい。また、if文を通らないときは自動でNoneが返る。
Construct Binary Tree from Inorder and Postorder Traversal,Medium,○,Preorder/Inorderの場合と対比させて考えるとわかりやすい。また、if文を通らないときは自動でNoneが返る。
Construct Binary Tree from Preorder and Postorder Traversal,Medium,,
Construct Binary Search Tree from Preorder Traversal,Medium,,
Construct String from Binary Tree,Easy,,
Construct Binary Tree from String,Medium,,
Minimum Distance Between BST Nodes,Easy,,
Split BST,Medium,○,再帰で解く。帰るときにrootの片方の葉に値を入れていくことがポイント。
Delete Node in a BST,Medium,,
Minimum Height Trees,Medium,,
Count Complete Tree Nodes,Medium,,
Binary Tree Maximum Path Sum,Hard,,
Serialize and Deserialize BST,Medium,○,平衡二分探索木なので、Nullはシリアライズしなくても大丈夫。
Serialize and Deserialize Binary Tree,Hard,○,BFS/DFSで走査しつつ、Nullを適宜保存する。
Serialize and Deserialize N-ary Tree,Hard,,
Count of Smaller Numbers After Self,Hard,,
Recover Binary Search Tree,Hard,,
Populating Next Right Pointers in Each Node,Medium,,
Populating Next Right Pointers in Each Node II,Medium,,
Count of Range Sum,Hard,,
,,,
"Graph, BFS, DFS",,,
Flood Fill,Easy,○,DFSでシンプルに解く。もちろんBFSでも解ける。
Nested List Weight Sum,Easy,○,DFS/BFSで各ノードの値と深さを走査する。NestedListIntegerのインターフェイスが一見分かりにくい。
Nested List Weight Sum II,Medium,○,DFS/BFSで各ノードの値と深さを走査する。Max_Depthを用いるのがポイント。
Clone Graph,Medium,,
Graph Valid Tree,Medium,,
Is Graph Bipartite?,Medium,,
Network Delay Time,Medium,,
Friend Circles,Medium,○,DFSやUnion-Findで解く。計算量はどちらもO(N^2)となる。
Accounts Merge,Medium,,
Most Stones Removed with Same Row or Column,Medium,,
Number of Connected Components in an Undirected Graph,Medium,○,経路圧縮+ランク付きUnion-Findの計算量はアッカーマン関数の逆関数α(N)となる。DFSやBFSでも勿論解ける。
Course Schedule,Medium,,
Course Schedule II,Medium,,
Course Schedule III,Medium,,
Number of Islands,Medium,○,DFSかBFSか、適当な走査法でgridの各点毎に探索する。計算量はO(面積)となる。
Number of Islands II,Hard,,
Max Area of Island,Medium,○,適当な走査法で、最大連結数をメモしつつgridの各点毎に探索する。計算量はO(面積)となる。
Evaluate Division,Medium,,
Word Ladder,Medium,○,始点と終点の双方向からのBFSで処理する。wordListをsetにしておかないと、in演算でO(N)となりTLEとなることに注意。
Word Ladder II,Hard,,
Optimal Account Balancing,Hard,,
Least Operators to Express Number,Hard,,
Walls and Gates,Medium,,
Surrounded Regions,Medium,,
Pacific Atlantic Water Flow,Medium,,
Reconstruct Itinerary,Medium,○,旅程が必ず存在するということを利用し、Stackを用いてGreedyに解く。
Minesweeper,Hard,,
Verifying an Alien Dictionary,Easy,○,辞書順のハッシュマップを用いて、素直に文字の順番を比較していく。
Alien Dictionary,Hard,,
Remove Invalid Parentheses,Hard,,
Minimize Malware Spread,Hard,,
Shortest Distance from All Buildings,Hard,,
Longest Increasing Path in a Matrix,Hard,,
Sliding Puzzle,Hard,,
Robot Room Cleaner,Hard,,
Cracking the Safe,Hard,,
24 Game,Hard,,
,,,
Dynamic Programming,,,
Fibonacci Number,Easy,○,メモ化だとO(N)、行列累乗または一般項の利用だとO(logN)で解ける。
Climbing Stairs,Easy,○,フィボナッチ数列の計算と同値となる。
Min Cost Climbing Stairs,Easy,○,DPでO(N)で解く。簡単な修正を加えてIn-Placeに解くこともできる。
Pascal's Triangle,Easy,○,パスカルの三角形の定義通りに実装する。
Pascal's Triangle II,Easy,○,逆順で足し合わせていくことによって空間計算量O(N)で解ける。
Triangle,Medium,○,DPでIn-Placeで解ける。
Paint Fence,Easy,○,同じ色で塗る場合と異なる色で塗る場合に分けてDPで解く。
Paint House,Easy,○,Dice Roll Simulationの簡易版。DPでO(NK)で解く。
Paint House II,Hard,○,Dice Roll Simulationの簡易版。DPでO(NK)で解く。
Longest Arithmetic Subsequence of Given Difference,Medium,○,ちゃんとO(N)で解けるDPの問題と見抜く。
Longest Increasing Subsequence,Medium,○,動的計画法+二分探索でO(NlogN)で解く。
Longest Palindromic Subsequence,Medium,○,iからjまででの最長回文の長さを記録する二次元配列を用いて、DPでO(N^2)で解く。
Longest Palindromic Substring,Medium,○,回文の長さが偶数か奇数で場合分けして、Two PointersでO(N^2)で解く。DPでO(N^2)で解くやり方や、ManacherでO(N)で解くやり方もある。
Palindromic Substrings,Medium,○,回文の長さが偶数か奇数で場合分けして、Two PointersでO(N^2)で解く。DPでO(N^2)で解くやり方や、ManacherでO(N)で解くやり方もある。
Maximum Subarray,Easy,○,全探索:O(N^3)、全探索＋累積和:O(N^2)、分割統治法:O(NlogN)、Kadane's Algorithm:O(N)の四通りの解き方がある。
K-Concatenation Maximum Sum,Medium,○,Kadane's AlgorithmでO(N)で解く。O(Nk)だとTLE/MLEしてしまうので、工夫して解く。
Maximum Product Subarray,Medium,○,絶対値が最大となる正数か負数で場合分けして、DPでO(N)で解く。0に関してはどちらかに含めれば良い。
Toss Strange Coins,Medium,○,二次元DPでO(NM)で解く。二次元配列は縦横共に1つ多めに用意する。
Dice Roll Simulation,Medium,○,三次元配列となる所を上手く工夫して、二次元DPでO(N)で解く。
Unique Paths,Medium,○,重複順列でシンプルに解ける。もちろんDPでも解ける。
Unique Paths II,Medium,○,DPでシンプルに解く。DPテーブルを作らなくてもIn-Placeで解ける。
Unique Paths III,Hard,,
House Robber,Easy,○,i番目の家で強盗した/しなかった場合の最大獲得金額を記録しながら走査する。
House Robber II,Medium,○,House Robberとほぼ同じ。始点と終点が繋がっているという追加条件がコーナーケースのような感じになる。
House Robber III,Medium,,
Knight Dialer,Medium,○,各ダイヤル番号の行き先のハッシュテーブルとメモ用変数を用いて、O(N)/O(1)のDPで解く。
Longest String Chain,Medium,○,単語の長さで昇順ソートした後、単語毎のDPテーブルを作ってO(NlogN)で解く。
Target Sum,Medium,,
Partition to K Equal Sum Subsets,Medium,,
Best Time to Buy and Sell Stock,Easy,○,その時点での最小買値と今までの最大売値を保存しつつ、前順でO(N)で解く。
Best Time to Buy and Sell Stock II,Easy,○,何も考えずに貪欲に解く。
Best Time to Buy and Sell Stock III,Hard,,
Best Time to Buy and Sell Stock IV,Hard,,
Best Time to Buy and Sell Stock with Cooldown,Medium,,
Best Time to Buy and Sell Stock with Transaction Fee,Medium,,
Range Sum Query - Immutable,Easy,○,累積和を用いてO(1)で処理する。
Range Sum Query - Mutable,Medium,,
Range Sum Query 2D - Immutable,Medium,○,累積和(動的計画法)を用いてO(1)で処理する。[[0]*n]*mだと各行のアドレスが全て同じになってしまうことに注意。
Range Sum Query 2D - Mutable,Hard,,
Interleaving String,Hard,,
Partition Equal Subset Sum,Medium,,
Decode Ways,Medium,○,i番目までのresとi-1番目までのresをメモしながらDPする。
Decode Ways II,Hard,,
Delete Operation for Two Strings,Medium,,
Perfect Squares,Medium,,
Maximal Square,Medium,○,[i-1][j-1]/[i-1][j]/[i][j-1]の部分問題に分けてメモ化しつつDPで解く。
Word Break,Medium,○,文字列の始点と終点に基づいたDPテーブルを作って解く。
Word Break II,Hard,,
Coin Change,Medium,○,DPで解く。日本の硬貨に限定すると、値段の高いものから貪欲に順に多く取っていけば最適解となる。
Coin Change 2,Medium,○,DPで解く。上記の問題とほぼ同様。
Minimum Path Sum,Medium,○,空間計算量は元の二次元配列に合計の距離を上書きしていけばO(1)で済む。
Regular Expression Matching,Hard,,
Edit Distance,Hard,,
Maximal Rectangle,Hard,,
Burst Balloons,Hard,,
Longest Valid Parentheses,Hard,,
Wildcard Matching,Hard,,
Frog Jump,Hard,,
Distinct Subsequences,Hard,,
Split Array Largest Sum,Hard,,
Create Maximum Number,Hard,,
Cherry Pickup,Hard,,
Russian Doll Envelopes,Hard,,
,,,
Binary Search,,,
Sqrt(x),Easy,○,二分探索で求める。ニュートン法でも求まるが、今回のテストケースの場合あまり速くならない。
Search Insert Position,Easy,○,ソートされているので、bisect等で二分探索すればO(logN)で解ける。
Is Subsequence,Medium,○,findメソッドの内部実装(BMH法)が高速なためか、Two Pointers+Greedyで二分探索より早く解ける。
Find Peak Element,Medium,,
Find Minimum in Rotated Sorted Array,Medium,○,反転している箇所を探すために、midとhighを比較して二分探索する。
Find Minimum in Rotated Sorted Array II,Hard,,
Find First and Last Position of Element in Sorted Array,Medium,,
Search in Rotated Sorted Array,Medium,○,探索対象列が回転しているかどうかで場合分けをする。
Search in Rotated Sorted Array II,Medium,,
Capacity To Ship Packages Within D Days,Medium,○,二分探索の問題と見抜くのが難しい。二分探索+貪欲にlower_boundを探していく。
Divide Two Integers,Medium,,
Search a 2D Matrix,Medium,○,二分探索を用いればO(NM)からO(logNM)に落とせる。ただ、実際はメモリアクセスの都合で速度は変わらない気がする。
Search a 2D Matrix II,Medium,○,探索開始位置を右上に設定すれば、O(N+M)で解ける。二分探索でもO(NlogM)orO(MlogN)で解ける。
Kth Smallest Element in a Sorted Matrix,Medium,,
Time Based Key-Value Store,Medium,○,timestampは昇順ソートされているので、そのまま二分探索が使える。
Smallest Rectangle Enclosing Black Pixels,Hard,,
Median of Two Sorted Arrays,Hard,○,jをiで上手く固定した後、B[j-1]<=A[i]かつA[i-1]<=B[j]を満たすiを二分探索で求める。
,,,
Bit Manipulation,,,
Power of Two,Easy,○,ビット演算で解く。0や負の数はFalseとなることに注意。
Power of Three,Easy,○,ビット演算は使わない。3**20<2**32<3**21を利用してO(1)で解く。
Power of Four,Easy,○,2の累乗チェックに加え、ビットが立つ位置を調べる操作を追加する。
Single Number,Easy,○,排他的論理和は可換となる性質を用いる。
Single Number II,Medium,,
Single Number III,Medium,,
Hamming Distance,Easy,○,排他的論理和を取って1の数を数えれば良い。
Total Hamming Distance,Medium,○,ビット列の各桁ごとの0と1の数を掛けたものを足し合わせれば良い。
Sum of Two Integers,Easy,○,XORとビットシフトを組み合わせて解く。Pythonだとかなりややこしい。
Majority Element,Easy,○,ハッシュマップで解くのが一番シンプル。ソート/ビット操作/Boyer-Mooreの多数決アルゴルズムでも解ける。
Missing Number,Easy,○,総和の公式を用いれば簡単に解ける。ビット演算でも解ける。
Reverse Bits,Easy,○,ビルトインメソッドで解くのが楽。使わない場合はビットシフトで解く。
Number of 1 Bits,Easy,○,ビルトインメソッドで解くのが楽。使わない場合はビットシフトで解く。
Gray Code,Medium,○,排他的論理和を用いて解く。再帰的にも解ける。
Counting Bits,Medium,,
UTF-8 Validation,Medium,○,問題文の条件を満たすか確認するコードを書く。UTF-8の文字が複数続くこともあるので注意。
Maximum Product of Word Lengths,Medium,,
,,,
"Two Pointers, Sliding Window",,,
Longest Repeating Character Replacement,Medium,○,尺取り法(Two Pointers/Sliding Window)を用いてO(N)で処理
Longest Substring Without Repeating Characters,Medium,○,尺取り法を用いてO(N)で処理
Minimum Size Subarray Sum,Medium,○,尺取り法を用いてO(N)で処理。累積和＋二分探索を用いてO(NlogN)に処理する方法もある
Get Equal Substrings Within Budget,Medium,○,rightはfor文で回して、leftはwhile文で調整する。costの計算はキューでO(1)でやらないとTLEする。
Permutation in String,Medium,,
Max Consecutive Ones,Easy,○,題意に従ってそのまま解く。
Max Consecutive Ones II,Medium,,
Max Consecutive Ones III,Medium,,
Container With Most Water,Medium,○,尺取り法を用いてO(N)で処理。横幅が大きい面積から処理していく。
Sort Colors,Medium,○,オランダ国旗問題と呼ばれる有名問題。色ごとのポインタを用いて処理する。
Interval List Intersections,Medium,○,Intersectionがある場合とない場合で分けて、Two Pointersで処理する。
3Sum,Medium,○,ソートした後、一番外側のループを回しつつ、内側の２変数はTwo Pointersで処理する。計算量はO(N^2)/O(1)となる。重複ペアの除外に注意。
3Sum Closest,Medium,○,ソートした後、一番外側のループを回しつつ、内側の２変数はTwo Pointersで処理する。計算量はO(N^2)/O(1)となる。
3Sum Smaller,Medium,○,上記の問題とほぼ同様。ただし、上記と同じ定数倍高速化をしようとすると、問題の設定上エラーとなることに注意。
Find the Duplicate Number,Medium,○,ランナーテクニックでフロイドの循環検出法を実装してO(N)で解く。二分探索だとO(NlogN)となる。
Minimum Window Substring,Hard,○,TがSに含まれるかどうかを辞書を用いて判定しつつ、Two PointerでO(N)で解く。
Sliding Window Maximum,Hard,,
Sliding Window Median,Hard,,
Longest Substring with At Most Two Distinct Characters,Hard,,
Longest Substring with At Most K Distinct Characters,Hard,,
,,,
"Greedy",,,
Meeting Rooms,Easy,○,開始時間でソートした後、前順にチェックしていく
Meeting Rooms II,Medium,○,開始時間でソートした後、heapで前順にチェックしていく(O(N)で済む)
Jump Game,Medium,○,到達可能な最大値を保存しつつ走査。GreedyにO(N)で解く。
Jump Game II,Hard,○,必ず最終地点に到達可能なことを利用し、Two Pointers+GreedyでO(N)で解く。
Campus Bikes,Medium,,
Campus Bikes II,Medium,,
Minimum Swaps to Make Strings Equal,Easy,○,問題文の例を参考にして、場合分けしてO(N)で解く。
String Without AAA or BBB,Medium,,
Minimum Domino Rotations For Equal Row,Medium,○,Counterはdefaultdictと同じく、存在しないキーの値は0を返すことに注意。
Partition Labels,Medium,○,最も右に現れるindexを保存する辞書を作り、それを用いつつTwo Pointersで貪欲に解く。
Reorganize String,Medium,,
Gas Station,Medium,,
Non-overlapping Intervals,Medium,,
Queue Reconstruction by Height,Medium,○,身長で降順ソート/前方許可人数で昇順ソートした後、前方許可人数に基づいて貪欲に列を構成する。
Remove K Digits,Medium,,
Remove Duplicate Letters,Hard,,
Merge Intervals,Medium,○,最初に開始時間でソートする。
Employee Free Time,Hard,○,Merge Intervalsとほぼ同じ問題。Employeeの区別はつけなくて良い。リスト内包表記の多重ループの書き方に気をつける。
Candy,Hard,○,Two-Passで貪欲に解く。One-Passでも解ける。
Patching Array,Hard,,
Minimum Number of K Consecutive Bit Flips,Hard,,
,,,
"Backtracking",,,
Permutations,Medium,○,バックトラッキングで解く。Subsetsと合わせて理解する。
Permutations II,Medium,○,バックトラッキングで解く。Subsetsと合わせて理解する。
Subsets,Medium,○,ビット演算、iterative、バックトラッキングのどれでも解ける。
Subsets II,Medium,○,iterative、バックトラッキングのどちらでも解ける。
Letter Combinations of a Phone Number,Medium,○,組み合わせ問題なのでバックトラック法で解く。
Generate Parentheses,Medium,○,計算量はカタラン数をスターリングの公式で近似したものになる。また、return/return None/returnなしはすべて同じ挙動となることに注意。
Palindrome Partitioning,Medium,,
Palindrome Partitioning II,Hard,,
Restore IP Addresses,Medium,,
N-Queens,Hard,,
N-Queens II,Hard,,
Valid Sudoku,Medium,○,各メソッドに分けて、題意をそれぞれチェックする。
Sudoku Solver,Hard,,
Generalized Abbreviation,Medium,,
Combinations,Medium,,
Combination Sum,Medium,○,バックトラッキングで解く。同じ要素を何回も使ってよいので、indexはi+1ではなくiを渡すことに注意。
Combination Sum II,Medium,○,バックトラッキングで解く。同じ要素は一回のみ使用可能なため、indexはi+1を渡すことに注意。
Combination Sum III,Medium,,
Combination Sum IV,Medium,,
,,,
Others(Design/SQL/Bash/Concurrency/etc),,,
Logger Rate Limiter,Easy,○,キューを用いて過去10秒以内のメッセージのみを保存する。
Number of Recent Calls,Easy,○,キューを使うと時間/空間計算量共にO(1)で毎回処理できる。
Implement Queue using Stacks,Easy,○,２つのスタックを用いてPushのみO(N)、他はO(1)で実装する
Implement Stack using Queues,Easy,,
Design Twitter,Medium,,
Flatten 2D Vector,Medium,,
Design Compressed String Iterator,Easy,,
Peeking Iterator,Medium,,
Zigzag Iterator,Medium,,
Design Phone Directory,Medium,,
Design Excel Sum Formula,Hard,,
Design In-Memory File System,Hard,,
Expression Add Operators,Hard,,
All O`one Data Structure,Hard,,
Design Hit Counter,Medium,○,timestampとヒット数を過去300秒分だけ保存する辞書を作り、O(1)で解く。
Design Log Storage System,Medium,,
Design Tic-Tac-Toe,Medium,○,プレイヤーの動きは毎回妥当だという事を利用する
The Skyline Problem,Hard,,
Guess the Word,Hard,,
Random Pick Index,Medium,,
Linked List Random Node,Medium,,
Random Pick with Blacklist,Hard,,
Random Flip Matrix,Medium,,
Random Point in Non-overlapping Rectangles,Medium,,
Random Pick with Weight,Medium,○,累積度数分布を作った後、二分探索でindexを求める。
Generate Random Point in a Circle,Medium,○,モンテカルロ法で解く。
Implement Rand10() Using Rand7(),Medium,○,上記の問題と同様。棄却サンプリングで解く。
Number of Boomerangs,Easy,○,三つ組の数え方に注意。iを固定した場合のjとkの組み合わせについて、全てのiに関して求める。
Check If It Is a Straight Line,Easy,○,傾きが等しくない場合はFalseとする。浮動小数点精度の誤差に注意する。
Line Reflection,Medium,○,反転した点があるか確認するための辞書を作ってO(N)で解く。
Minimum Area Rectangle,Medium,○,対角線上の点のみループで回して、他の２点は辞書でチェックしてO(N^2)で解く。
Minimum Area Rectangle II,Medium,○,内積が0かを確認するのと対角線側の点が存在することを確認し、対角線側の点は辞書でチェックしてO(N^3)で解く。
Max Points on a Line,Hard,○,傾きを辞書のキーとして用い、O(N^2)で処理していく。傾きが無限となる場合や、同じ座標の点がある場合に注意。
Erect the Fence,Hard,○,凸包を求める有名問題。ソートした後、上側凸包と下側凸包を外積を用いて求めていく。
Combine Two Tables,Easy,○,テーブルを結合して、それぞれの情報を抽出する。
Second Highest Salary,Easy,○,2番目に大きい値なので、最大値を除いた最大値を返す
Nth Highest Salary,Medium,○,LIMIT節では式は使えないことに注意。
Valid Phone Numbers,Easy,○,awk/grep/sed等、どれでも書ける
Tenth Line,Easy,○,awk/sed/head&tail等、どれでも書ける。ただ、head&tailは境界が紛らわしいのでawkとかの方が良いかも。
Word Frequency,Medium,○,sort/uniq等を上手く使って処理する。
Print in Order,Easy,○,バリア/イベント/ロック/セマフォ/コンディション等、様々な方法で排他制御ができる。
Building H2O,Medium,,
Print FooBar Alternately,Medium,○,バリア/イベント/ロック/セマフォ/コンディション等、様々な方法で排他制御ができる。
Print Zero Even Odd,Medium,,
