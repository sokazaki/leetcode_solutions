Problems,Difficulty,Solved,Notes (In Japanese)
"Array, Math, String",,,
Fizz Buzz,Easy,○,有名な問題
"Pow(x, n)",Medium,○,繰り返し二乗法を用いてO(logN)に落とす
Rotate Array,Easy,○,２つの部分列をそれぞれ反転させた後、全体の列を反転させる。
Non-decreasing Array,Easy,○,貪欲法っぽい感じでO(N)で解く。
Sort Array By Parity,Easy,○,Two Pointersを用いるとIn-PlaceでO(N)で解ける。
Sort Array By Parity II,Easy,○,Two Pointersを用いるとIn-PlaceでO(N)で解ける。偶奇の数は等しいので、片方の走査が終わった場合もう片方も終わっている。
String Compression,Easy,○,Two Pointersを使って空間計算量O(1)で解く。
Implement strStr(),Easy,,
Factorial Trailing Zeroes,Easy,○,素因数に関しては5に関してのみ調べれば良く、2について調べる必要はないことに注意。
Excel Sheet Column Number,Easy,,
Move Zeroes,Easy,○,走査用ポインタに加えて、0と交換する為のポインタを作って利用する。
Flipping an Image,Easy,○,問題文に従ってそのまま解く。
Count Primes,Easy,○,エラトステネスの篩で素数リストを作って、その長さを返す。
Shortest Unsorted Continuous Subarray,Easy,○,Two Pointersの前順/逆順操作でO(N)で解ける。境界条件に気を付ける。
Robot Return to Origin,Easy,○,countメソッドを使っても良い。
Palindrome Number,Easy,,
Find All Numbers Disappeared in an Array,Easy,○,バケツソートorハッシュテーブルを用いた方法はO(N)だが、余分なメモリを使うのでダメ。
Add Strings,Easy,○,文字列として処理しないと、多倍長整数を扱うPythonやJavaのBigInteger以外ではオーバーフローしてしまうことに注意。
Plus One,Easy,○,リストの最後尾から繰り上がりを足していき、O(N)で解く。
Count and Say,Easy,○,ヘルパー関数を作ることによって、やや実装が見やすくなる(気がする)。
To Lower Case,Easy,○,ASCIIコード表を利用して変換する。
Detect Capital,Easy,○,ビルトインメソッドを利用する。
Reorder Log Files,Easy,○,Pythonのビルトインのソートは安定ソートとなることを利用すると楽に書ける。
Roman to Integer,Easy,○,ハッシュテーブルを作ってやると簡単。
Integer to Roman,Medium,○,ハッシュテーブルを作ってやると簡単。
Merge Sorted Array,Easy,○,nums1とnums2を最後尾から比較しつつ、nums1に逆順で要素を入れていけば良い
Add Binary,Easy,○,再帰で解くと綺麗に書ける。リストのアクセスはO(1)なので計算量はO(N)となる。
Reverse String,Easy,○,reverseメソッドや、リストのスライスの逆順操作を用いても0(1)のin-placeになる。
Reverse Vowels of a String,Easy,○,小文字だけでなく大文字も母音となることに注意。
Reverse Integer,Easy,○,数字の文字列をintでキャストすると接頭の0を消すことができる。また文字列の逆順はスライスで行うのが便利。
Most Common Word,Easy,○,splitメソッドはスペースが複数個でも、自動的にスペースなしの単語リストに分割してくれる。
Multiply Strings,Medium,,
Super Ugly Number,Medium,,
Minimum Time Difference,Medium,○,時間を分に直してソートした後、前順に比較していく。最小時間+1440分を追加するとコードが簡単になる。また、バケツソートを用いるとO(N)にもできる。
Remove Duplicates from Sorted Array,Easy,○,Two Pointersを使うとO(N)でIn-Placeで解ける。
Find All Duplicates in an Array,Medium,,
Longest Common Prefix,Easy,○,zip関数をアスタリスク付きで上手く使う。
Longest Absolute File Path,Medium,,
Flip Game,Easy,○,題意に従ってそのまま解く。
Flip Game II,Medium,,
Game of Life,Medium,,
Next Permutation,Medium,○,最悪計算量はO(N)、償却計算量はO(1)となる
Summary Ranges,Medium,,
Product of Array Except Self,Medium,○,前順走査と逆順走査のTwo PassでO(N)で解く。
Maximum Average Subarray I,Easy,○,Sliding Windowで解く。ブルートフォースだとO(NK)になってしまう。
Maximum Average Subarray II,Hard,,
Rotate Image,Medium,○,zip関数を使うと簡単。返却値(リストの中身)がタプルとなることに注意。
Spiral Matrix,Medium,○,テンプレなので解き方を覚える。len([])は通るが、len([][0])はアクセスエラーになることに注意。
Spiral Matrix II,Medium,○,上とほぼ同じ問題。テンプレなので解き方を覚える。
Set Matrix Zeroes,Medium,,
Largest Number,Medium,○,Python3ではcmpパラメータは廃止されたので、代わりにkeyパラメータにcmp_to_keyでラップした比較関数を渡す。
ZigZag Conversion,Medium,○,シンプルにそのまま走査する。
String to Integer (atoi),Medium,○,問題の様々な条件を確認することが求められる、コーディング面接的な問題。
Fraction to Recurring Decimal,Medium,○,割り算の流れをそのまま素直に実装する。
Encode and Decode Strings,Medium,,
Reverse Words in a String,Medium,,
Insert Delete GetRandom O(1),Medium,,
Insert Delete GetRandom O(1) - Duplicates allowed,Hard,,
Find Duplicate File in System,Medium,,
Simplify Path,Medium,,
Shuffle an Array,Medium,,
Beautiful Array,Medium,,
K-th Symbol in Grammar,Medium,,
Wiggle Sort,Medium,○,条件を満たさない箇所を貪欲にスワップしていく事で、自然に題意を満たす列となる。
Wiggle Sort II,Medium,,
Missing Ranges,Medium,,
Increasing Triplet Subsequence,Medium,,
Find the Celebrity,Medium,,
Longest Substring with At Least K Repeating Characters,Medium,,
Insert Interval,Hard,,
Longest Consecutive Sequence,Hard,,
First Missing Positive,Hard,○,配列内に存在する数には負の符号をつけていき、O(N)/O(1)で処理する。
Text Justification,Hard,○,貪欲に空欄を追加していく。文字が一列に一つだけの場合に注意。
Shortest Palindrome,Hard,,
Valid Number,Hard,○,コーディング面接のような問題。様々な条件をしっかり議論する。
Consecutive Numbers Sum,Hard,,
Read N Characters Given Read4,Easy,,
Read N Characters Given Read4 II - Call multiple times,Hard,,
,,,
Trie,,,
Implement Trie (Prefix Tree),Medium,,
Implement Magic Dictionary,Medium,,
Map Sum Pairs,Medium,,
Replace Words,Medium,,
Maximum XOR of Two Numbers in an Array,Medium,,
Top K Frequent Words,Medium,,
Add and Search Word - Data structure design,Medium,,
Word Search,Medium,○,バックトラック法で解く。
Word Search II,Hard,,
Word Squares,Hard,,
Palindrome Pairs,Hard,○,各文字列を逆順にした辞書を用意して、O(NK**2)で解く。(Nは文字列の数、Kは文字列の長さ)
Design Search Autocomplete System,Hard,,
,,,
LinkedList,,,
Reverse Linked List,Easy,○,繰り返しと再帰の2ver.で解く (どちらも時間計算量はO(N))
Reverse Linked List II,Medium,,
Reverse Nodes in k-Group,Hard,,
Linked List Cycle,Easy,○,ランナーテクニックでフロイドの循環検出法を実装
Linked List Cycle II,Medium,○,実装は簡単。Noneの比較は==ではなくisで行う。
Add Two Numbers,Medium,○,ミュータブル/イミュータブル/参照の代入について理解する
Add Two Numbers II,Medium,○,スタックを用いて、各連結リストの中身を変更せずに解く。複数変数への同時代入は各式が左から順番に処理されていくことに注意。
Remove Linked List Elements,Easy,○,ダミーノードを作り、前順に走査していく。
Delete Node in a Linked List,Easy,,
Remove Duplicates from Sorted List,Easy,○,ポインタを付け替えるだけ
Remove Duplicates from Sorted List II,Medium,○,ダミーノードを作って上手く処理する
Remove Nth Node From End of List,Medium,○,参照の代入に気を付ける。n+aのfast/slowランナーを利用。
Copy List with Random Pointer,Medium,○,辞書を使って連結リストを処理
Palindrome Linked List,Easy,○,列の中間のノードを見つけて、その前後どちらかの列を逆順にして片方の列と比較していく。
Intersection of Two Linked Lists,Easy,○,それぞれ終端まで走査していき、列の長さを記録した後、それを用いて交差点を検出。
Odd Even Linked List,Medium,,
Reorder List,Medium,○,中央値発見/逆順並び替え/交互にマージの総合問題
Sort List,Medium,,
Swap Nodes in Pairs,Medium,○,一時変数を用いてノードを入れ替えていく。
Merge Two Sorted Lists,Easy,○,None or TrueはTrueになることに注意する
Merge k Sorted Lists,Hard,○,優先度付きキューを使う総合問題
Design Linked List,Easy,,
Flatten Binary Tree to Linked List,Medium,,
Convert Binary Search Tree to Sorted Doubly Linked List,Medium,,
LRU Cache,Medium,○,双方向連結リスト＋辞書を使う総合問題
LFU Cache,Hard,,
,,,
Stack,,,
Valid Parentheses,Easy,○,辞書を使って解く(括弧の向きが逆になることに注意)
Min Stack,Easy,○,最小値保存用のスタックを別に作成する
Max Stack,Easy,,
Decode String,Medium,○,繰り返し回数保存用のスタックを別に作成する
Daily Temperature,Medium,○,スタックを用いてforwardのループで上手く処理する
Flatten Nested List Iterator,Medium,○,pop()をO(1)で用いるために、最初にリストを逆順にする
Evaluate Reverse Polish Notation,Medium,,
Asteroid Collision,Medium,,
Trapping Rain Water,Hard,,
Trapping Rain Water II,Hard,,
Largest Rectangle in Histogram,Hard,,
Odd Even Jump,Hard,,
Basic Calculator,Hard,,
Basic Calculator II,Medium,,
Basic Calculator III,Hard,,
,,,
Queue,,,
Moving Average from Data Stream,Easy,,
Kill Process,Medium,,
Task Scheduler,Medium,,
Design Circular Queue,Medium,,
Design Circular Deque,Medium,,
Design Snake Game,Medium,,
,,,
"Heap, PriorityQueue",,,
Kth Largest Element in a Stream,Easy,,
K Closest Points to Origin,Medium,○,ヒープを使うと計算量をO(NlogN)からO(K+(N-K)logK)に落とせる。クイックセレクトの利用もあり。
Kth Largest Element in an Array,Medium,○,ヒープを使うと計算量をO(NlogN)からO(K+(N-K)logK)に落とせる。クイックセレクトの利用もあり。
Top K Frequent Elements,Medium,○,ヒープを使うと計算量がO(NlogN)となる。ハッシュマップ&バケツソートでO(N)にも出来る。
Find K Pairs with Smallest Sums,Medium,○,コーナーケースが多いので気をつける。ヒープを使うと計算量をO(NMlogNM)からO(KlogK)に落とせる。
Find Median from Data Stream,Hard,,
,,,
"HashMap, HashTable",,,
Jewels and Stones,Easy,○,ハッシュテーブルを使って普通に解く。
Subdomain Visit Count,Easy,○,ドメイン毎のハッシュテーブルを作って値を管理する。
Happy Number,Easy,○,ハッピー列が最終的に循環列になるという性質を利用する。
Two Sum,Easy,○,ハッシュテーブルを用いてO(N)で処理。_ in dictはvalueではなくkeyを見つける事に注意。
Two Sum III - Data structure design,Easy,,
Find Common Characters,Easy,,
Keyboard Row,Easy,,
Design HashMap,Easy,○,チェイン法を連結リストで実装する。returnとbreakの違いに注意。
Design HashSet,Easy,,
4Sum,Medium,,
4Sum II,Medium,,
Group Shifted Strings,Medium,,
Strobogrammatic Number,Easy,○,ストロボグラマティック数のハッシュテーブルを作って解く。
Strobogrammatic Number II,Medium,,
Strobogrammatic Number III,Hard,,
Intersection of Two Arrays,Easy,,
Intersection of Two Arrays II,Easy,,
Shortest Word Distance,Easy,,
Shortest Word Distance II,Medium,,
Shortest Word Distance III,Medium,,
H-Index,Medium,,
Valid Anagram,Easy,,
Valid Palindrome,Easy,○,Two PointersでO(N)で解ける。
Valid Palindrome II,Easy,○,Two PointersでO(N)で解ける。
Unique Word Abbreviation,Medium,,
Unique Email Addresses,Easy,○,ビルトインメソッドのsplitとreplaceを使うと簡単。
First Unique Character in a String,Easy,○,ハッシュマップを使ってTwo Passで解く。
Find All Anagrams in a String,Easy,,
Island Perimeter,Easy,○,True or 配列外のアクセスエラーはTrueとなることを利用。アクセスエラーを防ぐために外周を0埋めしても良い。
Contains Duplicate,Easy,○,ハッシュテーブルを用いてそのまま解く。setはO(N)でlenはO(1)となる。
Contains Duplicate II,Easy,○,ハッシュテーブルを用いてO(N)で解く。愚直に解くとO(N^2)となる。
Contains Duplicate III,Medium,,
Palindrome Permutation,Easy,○,ハッシュテーブルを用いてO(N)で解く。メモリを使いたくなければ、ソートを使ってO(NlogN)でも解ける。
Palindrome Permutation II,Medium,,
Group Anagrams,Medium,○,ハッシュテーブルを用いてO(N)で処理。dict.values()はPython3ではイテレータが返ってくることに注意。
Encode and Decode TinyURL,Medium,○,システムデザイン的な問題。base62で6桁だと62^6(約56.8Billion)のUniqueURLをカバーできる。
Subarray Sum Equals K,Medium,○,累積和のハッシュマップを作ってO(N)で解く。Two Sumと似た問題。
Subarray Sums Divisible by K,Medium,,
Binary Tree Vertical Order Traversal,Medium,,
Integer to English Words,Hard,○,再帰で書くと綺麗に書ける。2**32は10**9(Billion)から10**10(Ten Billion)の間であることに注意。
,,,
"Tree, BT, BST",,,
Same Tree,Easy,○,適当な走査法で全探索しつつ２つの木を比較していく。
Symmetric Tree,Easy,,
Merge Two Binary Trees,Easy,○,適当な走査法で全探索しつつ２つの木を足していく。
Subtree of Another Tree,Easy,,
Balanced Binary Tree,Easy,,
Invert Binary Tree,Easy,○,適当な走査法で全探索しつつ左右を反転していく。
Range Sum of BST,Easy,○,適当な走査法で枝狩りしつつ全探索していく。
Binary Tree Paths,Easy,,
Diameter of Binary Tree,Easy,,
Minimum Depth of Binary Tree,Easy,○,適当な走査法で木の高さを保存しながら探索しつつ、葉に到達したら終了する。
Maximum Depth of Binary Tree,Easy,,
Convert BST to Greater Tree,Easy,,
Convert Sorted Array to Binary Search Tree,Easy,○,再帰で解く。計算量はT(n)=2T(n/2)+O(1)より、マスター定理を用いてO(N)となる。
Convert Sorted List to Binary Search Tree,Medium,,
Closest Binary Search Tree Value,Easy,,
Closest Binary Search Tree Value II,Hard,,
Binary Tree Right Side View,Medium,,
Verify Preorder Serialization of a Binary Tree,Medium,,
Path Sum,Easy,○,適当な走査法で探索済みノードの値の総和を渡しつつ探索。
Path Sum II,Medium,,
Path Sum III,Easy,,
Path Sum IV,Medium,,
Longest Univalue Path,Easy,,
Lowest Common Ancestor of a Binary Search Tree,Easy,,
Two Sum IV - Input is a BST,Easy,,
Kth Smallest Element in a BST,Medium,,
Inorder Successor in BST,Medium,,
Binary Search Tree Iterator,Medium,,
Validate Binary Search Tree,Medium,,
Unique Binary Search Trees,Medium,,
Binary Tree Longest Consecutive Sequence,Medium,,
Binary Tree Longest Consecutive Sequence II,Medium,,
Lowest Common Ancestor of a Binary Tree,Medium,,
Binary Tree Inorder Traversal,Medium,,
Binary Tree Preorder Traversal,Medium,,
Binary Tree Postorder Traversal,Hard,,
Binary Tree Level Order Traversal,Medium,○,Level OrderなのでBFSが自然だが、Levelを渡しながら走査すればDFSでも解ける。
Binary Tree Level Order Traversal II,Easy,,
Binary Tree Zigzag Level Order Traversal,Medium,○,Binary Tree Level Order Traversalとほぼ同じ。作成したリストの奇数番目を最後に反転させる方法でも良い。
Construct Binary Tree from Preorder and Inorder Traversal,Medium,○,Inorder/Postorderの場合と対比させて考えるとわかりやすい。また、if文を通らないときは自動でNoneが返る。
Construct Binary Tree from Inorder and Postorder Traversal,Medium,○,Preorder/Inorderの場合と対比させて考えるとわかりやすい。また、if文を通らないときは自動でNoneが返る。
Construct Binary Tree from Preorder and Postorder Traversal,Medium,,
Construct Binary Search Tree from Preorder Traversal,Medium,,
Construct String from Binary Tree,Easy,,
Construct Binary Tree from String,Medium,,
Minimum Distance Between BST Nodes,Easy,,
Split BST,Medium,,
Delete Node in a BST,Medium,,
Minimum Height Trees,Medium,,
Count Complete Tree Nodes,Medium,,
Binary Tree Maximum Path Sum,Hard,,
Serialize and Deserialize BST,Medium,○,平衡二分探索木なので、Nullはシリアライズしなくても大丈夫。
Serialize and Deserialize Binary Tree,Hard,○,BFS/DFSで走査しつつ、Nullを適宜保存する。
Serialize and Deserialize N-ary Tree,Hard,,
Count of Smaller Numbers After Self,Hard,,
Recover Binary Search Tree,Hard,,
Populating Next Right Pointers in Each Node,Medium,,
Populating Next Right Pointers in Each Node II,Medium,,
Count of Range Sum,Hard,,
,,,
"Graph, BFS, DFS",,,
Flood Fill,Easy,○,DFSでシンプルに解く。もちろんBFSでも解ける。
Nested List Weight Sum,Easy,○,DFS/BFSで各ノードの値と深さを走査する。NestedListIntegerのインターフェイスが一見分かりにくい。
Nested List Weight Sum II,Medium,○,DFS/BFSで各ノードの値と深さを走査する。Max_Depthを用いるのがポイント。
Clone Graph,Medium,,
Graph Valid Tree,Medium,,
Is Graph Bipartite?,Medium,,
Network Delay Time,Medium,,
Friend Circles,Medium,○,DFSやUnion-Findで解く。計算量はどちらもO(N^2)となる。
Accounts Merge,Medium,,
Most Stones Removed with Same Row or Column,Medium,,
Number of Connected Components in an Undirected Graph,Medium,○,経路圧縮+ランク付きUnion-Findの計算量はアッカーマン関数の逆関数α(N)となる。DFSやBFSでも勿論解ける。
Course Schedule,Medium,,
Course Schedule II,Medium,,
Course Schedule III,Medium,,
Number of Islands,Medium,○,DFSかBFSか、適当な走査法でgridの各点毎に探索する。計算量はO(面積)となる。
Number of Islands II,Hard,,
Max Area of Island,Medium,○,適当な走査法で、最大連結数をメモしつつgridの各点毎に探索する。計算量はO(面積)となる。
Evaluate Division,Medium,,
Word Ladder,Medium,○,始点と終点の双方向からのBFSで処理する。wordListをsetにしておかないと、in演算でO(N)となりTLEとなることに注意。
Word Ladder II,Hard,,
Optimal Account Balancing,Hard,,
Least Operators to Express Number,Hard,,
Walls and Gates,Medium,,
Surrounded Regions,Medium,,
Pacific Atlantic Water Flow,Medium,,
Reconstruct Itinerary,Medium,,
Minesweeper,Hard,,
Verifying an Alien Dictionary,Easy,○,辞書順のハッシュマップを用いて、素直に文字の順番を比較していく。
Alien Dictionary,Hard,,
Remove Invalid Parentheses,Hard,,
Minimize Malware Spread,Hard,,
Shortest Distance from All Buildings,Hard,,
Longest Increasing Path in a Matrix,Hard,,
Sliding Puzzle,Hard,,
Robot Room Cleaner,Hard,,
Cracking the Safe,Hard,,
24 Game,Hard,,
,,,
Dynamic Programming,,,
Fibonacci Number,Easy,○,メモ化だとO(N)、行列累乗または一般項の利用だとO(logN)で解ける。
Climbing Stairs,Easy,○,フィボナッチ数列の計算と同値となる。
Min Cost Climbing Stairs,Easy,,
Pascal's Triangle,Easy,,
Pascal's Triangle II,Easy,,
Triangle,Medium,○,DPでIn-Placeで解ける。
Paint Fence,Easy,○,同じ色で塗る場合と異なる色で塗る場合に分けてDPで解く。
Longest Increasing Subsequence,Medium,,
Longest Palindromic Subsequence,Medium,,
Longest Palindromic Substring,Medium,,
Palindromic Substrings,Medium,,
Maximum Subarray,Easy,○,全探索:O(N^3)、全探索＋累積和:O(N^2)、分割統治法:O(NlogN)、Kadane's Algorithm:O(N)の四通りの解き方がある。
Maximum Product Subarray,Medium,○,正の数と負の数をメモしつつDPで解く。
Unique Paths,Medium,○,重複順列でシンプルに解ける。もちろんDPでも解ける。
Unique Paths II,Medium,○,DPでシンプルに解く。DPテーブルを作らなくてもIn-Placeで解ける。
Unique Paths III,Hard,,
House Robber,Easy,○,i番目の家で強盗した/しなかった場合の最大獲得金額を記録しながら走査する。
House Robber II,Medium,○,House Robberとほぼ同じ。始点と終点が繋がっているという追加条件がコーナーケースのような感じになる。
House Robber III,Medium,,
Knight Dialer,Medium,○,各ダイヤル番号の行き先のハッシュテーブルとメモ用変数を用いて、O(N)/O(1)のDPで解く。
Longest String Chain,Medium,○,単語の長さで昇順ソートした後、単語毎のDPテーブルを作ってO(NlogN)で解く。
Target Sum,Medium,,
Partition to K Equal Sum Subsets,Medium,,
Best Time to Buy and Sell Stock,Easy,○,その時点での最小買値と今までの最大売値を保存しつつ、前順でO(N)で解く。
Best Time to Buy and Sell Stock II,Easy,○,何も考えずに貪欲に解く。
Best Time to Buy and Sell Stock III,Hard,,
Best Time to Buy and Sell Stock IV,Hard,,
Best Time to Buy and Sell Stock with Cooldown,Medium,,
Best Time to Buy and Sell Stock with Transaction Fee,Medium,,
Range Sum Query - Immutable,Easy,,
Range Sum Query - Mutable,Medium,,
Range Sum Query 2D - Immutable,Medium,,
Range Sum Query 2D - Mutable,Hard,,
Interleaving String,Hard,,
Partition Equal Subset Sum,Medium,,
Decode Ways,Medium,○,i番目までのresとi-1番目までのresをメモしながらDPする。
Decode Ways II,Hard,,
Delete Operation for Two Strings,Medium,,
Perfect Squares,Medium,,
Maximal Square,Medium,○,[i-1][j-1]/[i-1][j]/[i][j-1]の部分問題に分けてメモ化しつつDPで解く。
Word Break,Medium,○,文字列の始点と終点に基づいたDPテーブルを作って解く。
Word Break II,Hard,,
Coin Change,Medium,○,DPでシンプルに解く。日本の硬貨に限定すると、値段の高いものから貪欲に順に多く取っていけば最適解となる。
Coin Change 2,Medium,,
Minimum Path Sum,Medium,○,空間計算量は元の二次元配列に合計の距離を上書きしていけばO(1)で済む。
Regular Expression Matching,Hard,,
Edit Distance,Hard,,
Maximal Rectangle,Hard,,
Burst Balloons,Hard,,
Longest Valid Parentheses,Hard,,
Wildcard Matching,Hard,,
Frog Jump,Hard,,
Distinct Subsequences,Hard,,
Split Array Largest Sum,Hard,,
Create Maximum Number,Hard,,
Cherry Pickup,Hard,,
Russian Doll Envelopes,Hard,,
,,,
Binary Search,,,
Sqrt(x),Easy,○,二分探索で求める。ニュートン法でも求まるが、今回のテストケースの場合あまり速くならない。
Search Insert Position,Easy,○,ソートされているので、bisect等で二分探索すればO(logN)で解ける。
Is Subsequence,Medium,○,findメソッドの内部実装(BMH法)が高速なためか、Two Pointers+Greedyで二分探索より早く解ける。
Find Peak Element,Medium,,
Find Minimum in Rotated Sorted Array,Medium,,
Find Minimum in Rotated Sorted Array II,Hard,,
Find First and Last Position of Element in Sorted Array,Medium,,
Search in Rotated Sorted Array,Medium,,
Search in Rotated Sorted Array II,Medium,,
Capacity To Ship Packages Within D Days,Medium,,
Divide Two Integers,Medium,,
Search a 2D Matrix,Medium,○,二分探索を用いればO(NM)からO(logNM)に落とせる。ただ、実際はメモリアクセスの都合で速度は変わらない気がする。
Search a 2D Matrix II,Medium,○,探索開始位置を右上に設定すれば、O(N+M)で解ける。二分探索でもO(NlogM)orO(MlogN)で解ける。
Kth Smallest Element in a Sorted Matrix,Medium,,
Time Based Key-Value Store,Medium,○,timestampは昇順ソートされているので、そのまま二分探索が使える。
Random Pick with Weight,Medium,○,累積度数分布を作った後、二分探索でindexを求める。
Smallest Rectangle Enclosing Black Pixels,Hard,,
Median of Two Sorted Arrays,Hard,○,jをiで上手く固定した後、B[j-1]<=A[i]かつA[i-1]<=B[j]を満たすiを二分探索で求める。
,,,
Bit Manipulation,,,
Power of Two,Easy,○,ビット演算で解く。0や負の数はFalseとなることに注意。
Power of Three,Easy,○,ビット演算は使わない。3**20<2**32<3**21を利用してO(1)で解く。
Power of Four,Easy,○,2の累乗チェックに加え、ビットが立つ位置を調べる操作を追加する。
Single Number,Easy,○,排他的論理和は可換となる性質を用いる。
Single Number II,Medium,,
Single Number III,Medium,,
Hamming Distance,Easy,○,排他的論理和を取って1の数を数えれば良い。
Total Hamming Distance,Medium,○,ビット列の各桁ごとの0と1の数を掛けたものを足し合わせれば良い。
Sum of Two Integers,Easy,○,XORとビットシフトを組み合わせて解く。aまたはbが負の場合に注意する。
Majority Element,Easy,○,ハッシュマップで解くのが一番シンプル。ソート/ビット操作/Boyer-Mooreの多数決アルゴルズムでも解ける。
Missing Number,Easy,○,総和の公式を用いれば簡単に解ける。ビット演算でも解ける。
Reverse Bits,Easy,○,ビルトインメソッドで解くのが楽。使わない場合はビットシフトで解く。
Number of 1 Bits,Easy,○,ビルトインメソッドで解くのが楽。使わない場合はビットシフトで解く。
Gray Code,Medium,○,排他的論理和を用いて解く。再帰的にも解ける。
Counting Bits,Medium,,
UTF-8 Validation,Medium,,
Maximum Product of Word Lengths,Medium,,
,,,
"Two Pointers, Sliding Window",,,
Longest Repeating Character Replacement,Medium,○,尺取り法(Two Pointers/Sliding Window)を用いてO(N)で処理
Longest Substring Without Repeating Characters,Medium,○,尺取り法を用いてO(N)で処理
Minimum Size Subarray Sum,Medium,○,尺取り法を用いてO(N)で処理。累積和＋二分探索を用いてO(NlogN)に処理する方法もある
Permutation in String,Medium,,
Max Consecutive Ones,Easy,○,題意に従ってそのまま解く。
Max Consecutive Ones II,Medium,,
Max Consecutive Ones III,Medium,,
Container With Most Water,Medium,○,尺取り法を用いてO(N)で処理。横幅が大きい面積から処理していく。
Sort Colors,Medium,○,オランダ国旗問題と呼ばれる有名問題。色ごとのポインタを用いて処理する。
Interval List Intersections,Medium,,
Two Sum II - Input array is sorted,Easy,○,Two Sumと同じくハッシュマップでO(N)で解けるが、ソートされてるのでTwo PointersでもO(N)で解ける。
3Sum,Medium,,
3Sum Closest,Medium,,
3Sum Smaller,Medium,,
Find the Duplicate Number,Medium,○,ランナーテクニックでフロイドの循環検出法を実装してO(N)で解く。二分探索だとO(NlogN)となる。
Minimum Window Substring,Hard,,
Sliding Window Maximum,Hard,,
Sliding Window Median,Hard,,
Longest Substring with At Most Two Distinct Characters,Hard,,
Longest Substring with At Most K Distinct Characters,Hard,,
,,,
"Greedy",,,
Meeting Rooms,Easy,○,開始時間でソートした後、前順にチェックしていく
Meeting Rooms II,Medium,○,開始時間でソートした後、heapで前順にチェックしていく(O(N)で済む)
Jump Game,Medium,,
Jump Game II,Hard,,
Campus Bikes,Medium,,
Campus Bikes II,Medium,,
String Without AAA or BBB,Medium,,
Minimum Domino Rotations For Equal Row,Medium,○,Counterはdefaultdictと同じく、存在しないキーの値は0を返すことに注意。
Partition Labels,Medium,,
Reorganize String,Medium,,
Gas Station,Medium,,
Non-overlapping Intervals,Medium,,
Queue Reconstruction by Height,Medium,○,身長で降順ソート/前方許可人数で昇順ソートした後、前方許可人数に基づいて貪欲に列を構成する。
Remove K Digits,Medium,,
Remove Duplicate Letters,Hard,,
Merge Intervals,Medium,,
Employee Free Time,Hard,○,Merge Intervalsとほぼ同じ問題。Employeeの区別はつけなくて良い。リスト内包表記の多重ループの書き方に気をつける。
Candy,Hard,○,Two-Passで貪欲に解く。One-Passでも解ける。
Patching Array,Hard,,
Minimum Number of K Consecutive Bit Flips,Hard,,
,,,
"Backtracking",,,
Permutations,Medium,○,素直にitertoolsを使うのが一番速い。想定解はバックトラッキング。
Permutations II,Medium,○,itertools/set/sortedで処理しても十分に速い。想定解はバックトラッキング。
Subsets,Medium,,
Subsets ll,Medium,,
Letter Combinations of a Phone Number,Medium,○,組み合わせ問題なのでバックトラック法で解く。
Generate Parentheses,Medium,○,計算量はカタラン数をスターリングの公式で近似したものになる。また、return/return None/returnなしはすべて同じ挙動となることに注意。
Palindrome Partitioning,Medium,,
Palindrome Partitioning II,Hard,,
Restore IP Addresses,Medium,,
N-Queens,Hard,,
N-Queens II,Hard,,
Valid Sudoku,Medium,○,各メソッドに分けて、題意をそれぞれチェックする。
Sudoku Solver,Hard,,
Generalized Abbreviation,Medium,,
Combinations,Medium,,
Combination Sum,Medium,,
Combination Sum II,Medium,,
Combination Sum III,Medium,,
Combination Sum IV,Medium,,
,,,
Others(Design/SQL/Bash/Concurrency/etc),,,
Logger Rate Limiter,Easy,,
Number of Recent Calls,Easy,,
Implement Queue using Stacks,Easy,,
Implement Stack using Queues,Easy,,
Design Twitter,Medium,,
Flatten 2D Vector,Medium,,
Design Compressed String Iterator,Easy,,
Peeking Iterator,Medium,,
Zigzag Iterator,Medium,,
Design Phone Directory,Medium,,
Design Excel Sum Formula,Hard,,
Design In-Memory File System,Hard,,
Expression Add Operators,Hard,,
All O`one Data Structure,Hard,,
Design Hit Counter,Medium,○,timestampとヒット数を過去300秒分だけ保存する辞書を作り、O(1)で解く。
Design Log Storage System,Medium,,
Design Tic-Tac-Toe,Medium,,
The Skyline Problem,Hard,,
Guess the Word,Hard,,
Max Points on a Line,Hard,,
Combine Two Tables,Easy,○,テーブルを結合して、それぞれの情報を抽出する。
Second Highest Salary,Easy,○,2番目に大きい値なので、最大値を除いた最大値を返す
Nth Highest Salary,Medium,○,LIMIT節では式は使えないことに注意。
Valid Phone Numbers,Easy,○,awk/grep/sed等、どれでも書ける
Tenth Line,Easy,○,awk/sed/head&tail等、どれでも書ける。ただ、head&tailは境界が紛らわしいのでawkとかの方が良いかも。
Word Frequency,Medium,○,sort/uniq等を上手く使って処理する。
Print in Order,Easy,,
Building H2O,Medium,,
Print FooBar Alternately,Medium,,
Print Zero Even Odd,Medium,,
